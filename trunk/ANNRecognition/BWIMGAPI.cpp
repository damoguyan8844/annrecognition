#include "stdafx.h"
#include "ANNRecognition.h"
#include <iostream>
#include <vector>
#include <math.h>
#include <ximacfg.h>
#include <ximage.h>
#include <ximatif.h>

using namespace std;


typedef deque<RECT>  CRectLink;
typedef deque<HDIB>  HDIBLink;


//???????????
int m_lianXuShu;
std::vector<CRectLink> g_CharSegmentRet;

/*********************************** ************************************
????:DisplayDIB
??:
	CDC* pDC			-?????????(Divice Context)???
	HDIB hDIB			-?????????
**********************************************************************/

ANNRECOGNITION_API void DisplayDIB(HDC pDC,HDIB hDIB)
{
	BYTE* lpDIB=(BYTE*)::GlobalLock((HGLOBAL)hDIB);
	// ??DIB?????
	int cxDIB =  ::DIBWidth((char*) lpDIB);
	int cyDIB =  ::DIBHeight((char*)lpDIB);
	RECT rcDIB,rcDest;
	rcDIB.top = rcDIB.left = 0;
	rcDIB.right = cxDIB;
	rcDIB.bottom = cyDIB;
	//?????????????
	rcDest = rcDIB;
	//CDC* pDC=GetDC();
	ClearAll(pDC);
	//????????
	//for(int ii=0;ii<10;ii++)
		::PaintDIB(pDC,&rcDest,hDIB,&rcDIB,NULL);
	::GlobalUnlock((HGLOBAL)hDIB);
}

ANNRECOGNITION_API void ClearAll(HDC pDC)
{
	RECT rect;
	//GetClientRect(&rect);
	rect.left =0;rect.top =0;rect.right =2000;rect.bottom =1000;
	CPen pen;
	pen.CreatePen (PS_SOLID,1,RGB(255,255,255));
	
	CDC tempDC;
	tempDC.Attach(pDC);
	tempDC.SelectPen((HPEN)pen);
	tempDC.Rectangle(&rect);
	tempDC.Detach();
	::DeleteObject(pen);
}
/*******************************************
*
*  ????:
*  AutoAlign()
*
*  ??:
*    HDIB   hDIB        -??????
*
*  ???   
*    HDIB               -????????????
*
*  ??:
*     ???????????????????,?????????
*
*  ??:
*     ???????????????????
*
********************************************************/


ANNRECOGNITION_API HDIB AutoAlign(HDIB hDIB,LONG charRectID)
{   
	if(charRectID>=g_CharSegmentRet.size()) return 0;
	CRectLink & m_charRect=g_CharSegmentRet[charRectID];
	if(m_charRect.empty()) return 0;

	int digicount = m_charRect.size();
	
	//???????
 	BYTE* lpDIB=(BYTE*)::GlobalLock ((HGLOBAL)hDIB);

	//???????????
	BYTE* lpDIBBits=(BYTE*)::FindDIBBits ((char*)lpDIB);

	//???????
	BYTE* lpSrc;

	//???????
	LONG lWidth=::DIBWidth ((char*)lpDIB);

	//???????
	LONG lHeight=::DIBHeight ((char*)lpDIB);

	//????????
	int w=RECTWIDTH(&m_charRect.front ());

	//????????
	int h=RECTHEIGHT(&m_charRect.front ());

	//???????????????????????
	HDIB hNewDIB=::NewDIB (digicount*w,h,8);

	//?????????
	BYTE* lpNewDIB=(BYTE*) ::GlobalLock((HGLOBAL)hNewDIB);
	
	//???????????
	BYTE* lpNewDIBBits=(BYTE*)::FindDIBBits((char*)lpNewDIB);

	//???????
	BYTE* lpDst=lpNewDIBBits;

	//???????????
	LONG lLineBytes=(lWidth+3)/4*4;

	//???????????
	LONG lLineBytesnew =(digicount*w+3)/4*4;

	//???????????
	memset(lpDst,(BYTE)255,lLineBytesnew * h);

	//?????????
	int i_src,j_src;

	//????
	int i,j;

	//?????????
	int counts=0;

	//??????????
	RECT rect,rectnew;

	//???????????????????
	
	CRectLink m_charRectCopy;

	//????????????????
	while(!m_charRect.empty() )
	{   
		//???????????
		rect=m_charRect.front ();

		//????????????
		m_charRect.pop_front ();

		//????????????

		//???
		rectnew.left =counts*w;

		//???
		rectnew.right =(counts+1)*w;

		//???
		rectnew.top =0;

		//???
		rectnew.bottom =h;

		//?????????????????
		m_charRectCopy.push_back (rectnew);

		//??????????????????
		for(i=0;i<h;i++)
		{  
			for(j=counts*w;j<(counts+1)*w;j++)
			{   

				//??????
	          	i_src=rect.top +i;
				j_src=rect.left +j-counts*w;

				//???????
				lpSrc=(BYTE *)lpDIBBits + lLineBytes *  i_src + j_src;
				lpDst=(BYTE *)lpNewDIBBits + lLineBytesnew * i + j;
				*lpDst=*lpSrc;
			}
		}

		//?????1
		counts++;
		
	}

	//???????????????,?????????
	m_charRect=m_charRectCopy;

	//????
	::GlobalUnlock (hDIB);


	::GlobalUnlock (hNewDIB);
	return hNewDIB;
}


/**************************************************
* ????:
*     ThinnerHilditch
*
* ??:
*   void*     image             -???????????1????0
*   unsigned  longlx             -?????
*   unsigned  longly             -?????
*
* ???
*       ?
*
*????:
*       ??????????,????????
***********************************************************/

ANNRECOGNITION_API void ThinnerHilditch(void *image, unsigned long lx, unsigned long ly)
{
    char *f, *g;
    char n[10];
    unsigned int counter;
    short k, shori, xx, nrn;
    unsigned long i, j;
    long kk, kk11, kk12, kk13, kk21, kk22, kk23, kk31, kk32, kk33, size;
    size = (long)lx * (long)ly;
    g = (char *)malloc(size);

    if(g == NULL)
    {
       // printf("error in allocating memory!\n");
        return;
    }

    f = (char *)image;
    for(i=0; i<lx; i++)
    {
        for(j=0; j<ly; j++)
        {
            kk=i*ly+j;
            if(f[kk]!=0)
            {
                f[kk]=1;
                g[kk]=f[kk];
            }
        }
    }

    counter = 1;

    do
    {
        
        counter++;
        shori = 0;

        for(i=0; i<lx; i++)
        {
            for(j=0; j<ly; j++)
            {
                kk = i*ly+j;
                if(f[kk]<0)
                    f[kk] = 0;
                g[kk]= f[kk];
            }
        }

        for(i=1; i<lx-1; i++)
        {
            for(j=1; j<ly-1; j++)
            {
                kk=i*ly+j;

                if(f[kk]!=1)
                    continue;

                kk11 = (i-1)*ly+j-1;
                kk12 = kk11 + 1;
                kk13 = kk12 + 1;
                kk21 = i*ly+j-1;
                kk22 = kk21 + 1;
                kk23 = kk22 + 1;
                kk31 = (i+1)*ly+j-1;
                kk32 = kk31 + 1;
                kk33 = kk32 + 1;

                if((g[kk12]&&g[kk21]&&g[kk23]&&g[kk32])!=0)
                    continue;

                nrn = g[kk11] + g[kk12] + g[kk13] + g[kk21] + g[kk23] + 
                    g[kk31] + g[kk32] + g[kk33];

                if(nrn <= 1)
                {
                    f[kk22] = 2;
                    continue;
                }

                n[4] = f[kk11];
                n[3] = f[kk12];
                n[2] = f[kk13];
                n[5] = f[kk21];
                n[1] = f[kk23];
                n[6] = f[kk31];
                n[7] = f[kk32];
                n[8] = f[kk33];
                n[9] = n[1];
                xx = 0;

                for(k=1; k<8; k=k+2)
                {
                    if((!n[k])&&(n[k+1]||n[k+2]))
                        xx++;
                }

                if(xx!=1)
                {
                    f[kk22] = 2;
                    continue;
                }

                if(f[kk12] == -1)
                {
                    f[kk12] = 0;
                    n[3] = 0;
                    xx = 0;

                    for(k=1; k<8; k=k+2)
                    {
                        if((!n[k])&&(n[k+1]||n[k+2]))
                            xx++;
                    }

                    if(xx != 1)
                    {
                        f[kk12] = -1;
                        continue;
                    }

                    f[kk12] = -1;
                    n[3] = -1;
                }

                if(f[kk21]!=-1)
                {
                    f[kk22] = -1;
                    shori = 1;
                    continue;
                }

                f[kk21] = 0;
                n[5] = 0;
                xx = 0;

                for(k=1; k<8; k=k+2)
                {
                    if((!n[k])&&(n[k+1]||n[k+2]))
                    {
                        xx++;
                    }
                }

                if(xx == 1)
                {
                    f[kk21] = -1;
                    f[kk22] = -1;
                    shori =1;
                }
                else
                    f[kk21] = -1;
            }
        }
    }while(shori);

    free(g);
}

/**************************************************
* ????:
*     ThinnerRosenfeld
*
* ??:
*   void*     image             -???????????1????0
*   unsigned  longlx             -?????
*   unsigned  longly             -?????
*
* ???
*       ?
*
*????:
*       ??????????,????????
***********************************************************/
ANNRECOGNITION_API void ThinnerRosenfeld(void *image, unsigned long lx, unsigned long ly)
{
    char *f, *g;
    char n[10];
    char a[5] = {0, -1, 1, 0, 0};
    char b[5] = {0, 0, 0, 1, -1};
    char nrnd, cond, n48, n26, n24, n46, n68, n82, n123, n345, n567, n781;
    short k, shori;
    unsigned long i, j;
    long ii, jj, kk, kk1, kk2, kk3, size;
    size = (long)lx * (long)ly;

    g = (char *)malloc(size);
    if(g==NULL)
    {
        printf("error in alocating mmeory!\n");
        return;
    }

    f = (char *)image;
    for(kk=0l; kk<size; kk++)
    {
        g[kk] = f[kk];
    }

    do
    {
        shori = 0;
        for(k=1; k<=4; k++)
        {
            for(i=1; i<lx-1; i++)
            {
                ii = i + a[k];

                for(j=1; j<ly-1; j++)
                {
                    kk = i*ly + j;

                    if(!f[kk])
                        continue;

                    jj = j + b[k];
                    kk1 = ii*ly + jj;

                    if(f[kk1])
                        continue;

                    kk1 = kk - ly -1;
                    kk2 = kk1 + 1;
                    kk3 = kk2 + 1;
                    n[3] = f[kk1];
                    n[2] = f[kk2];
                    n[1] = f[kk3];
                    kk1 = kk - 1;
                    kk3 = kk + 1;
                    n[4] = f[kk1];
                    n[8] = f[kk3];
                    kk1 = kk + ly - 1;
                    kk2 = kk1 + 1;
                    kk3 = kk2 + 1;
                    n[5] = f[kk1];
                    n[6] = f[kk2];
                    n[7] = f[kk3];

                    nrnd = n[1] + n[2] + n[3] + n[4]
                        +n[5] + n[6] + n[7] + n[8];
                    if(nrnd<=1)
                        continue;

                    cond = 0;
                    n48 = n[4] + n[8];
                    n26 = n[2] + n[6];
                    n24 = n[2] + n[4];
                    n46 = n[4] + n[6];
                    n68 = n[6] + n[8];
                    n82 = n[8] + n[2];
                    n123 = n[1] + n[2] + n[3];
                    n345 = n[3] + n[4] + n[5];
                    n567 = n[5] + n[6] + n[7];
                    n781 = n[7] + n[8] + n[1];

                    if(n[2]==1 && n48==0 && n567>0)
                    {
                        if(!cond)
                            continue;
                        g[kk] = 0;
                        shori = 1;
                        continue;
                    }

                    if(n[6]==1 && n48==0 && n123>0)
                    {
                        if(!cond)
                            continue;
                        g[kk] = 0;
                        shori = 1;
                        continue;
                    }

                    if(n[8]==1 && n26==0 && n345>0)
                    {
                        if(!cond)
                            continue;
                        g[kk] = 0;
                        shori = 1;
                        continue;
                    }

                    if(n[4]==1 && n26==0 && n781>0)
                    {
                        if(!cond)
                            continue;
                        g[kk] = 0;
                        shori = 1;
                        continue;
                    }

                    if(n[5]==1 && n46==0)
                    {
                        if(!cond)
                            continue;
                        g[kk] = 0;
                        shori = 1;
                        continue;
                    }

                    if(n[7]==1 && n68==0)
                    {
                        if(!cond)
                            continue;
                        g[kk] = 0;
                        shori = 1;
                        continue;
                    }

                    if(n[1]==1 && n82==0)
                    {
                        if(!cond)
                            continue;
                        g[kk] = 0;
                        shori = 1;
                        continue;
                    }

                    if(n[3]==1 && n24==0)
                    {
                        if(!cond)
                            continue;
                        g[kk] = 0;
                        shori = 1;
                        continue;
                    }

                    cond = 1;
                    if(!cond)
                        continue;
                    g[kk] = 0;
                    shori = 1;
                }
            }

            for(i=0; i<lx; i++)
            {
                for(j=0; j<ly; j++)
                {
                    kk = i*ly + j;
                    f[kk] = g[kk];
                }
            }
        }
    }while(shori);

    free(g);
}              


/*************************************************
*
* ????:
*       CharSegment()
*
*  ??:
*      HDIB  hDIB      -??????
*
*  ???:
*     {(left,top,right,bottom)}        -?????????????????
*
* ??:
*    ?????????????????????????????????
*
*  ??:
*    ??????2??????????
*
*********************************************************/


ANNRECOGNITION_API LONG CharSegment(HDIB hDIB)
{
	
	//???????????????
	CRectLink charRect1,charRect2;
	charRect1.clear();
	charRect2.clear();

	// ??DIB???
	LPSTR lpDIB=(LPSTR) ::GlobalLock((HGLOBAL)hDIB);
	
	// ??DIB????
	LPSTR    lpDIBBits;	

	// ??DIB????????
	lpDIBBits = ::FindDIBBits(lpDIB);
	
	//????????
	BYTE* lpSrc;

	//????????
	int height,width;

	//???????
	width=(int)::DIBWidth(lpDIB);

	//???????
	height=(int)::DIBHeight(lpDIB);

	//??????????
	LONG	lLineBytes = WIDTHBYTES(width * 8);

	//??????????
	int top,bottom;

    //??????
    int gray; 

	//??????
	int i,j;

	//???????????????
//	digicount=0;


	//??????,?????

	//?
	for (i=0;i<height;i++)
	{
         //?
  		for (j=0;j<width;j++)
		{
            // ?????i?,?j??????
			lpSrc = (unsigned char*)lpDIBBits + lLineBytes * i + j;

			//????????
			gray = *(lpSrc);

			//??????
			if (gray == 0)
			{   
               //????,?????????????
				top = i;

				//?i?????????
				i=height;

				//????
				break;
			}

        //????????,????
		}
	}


    //??????,????

	//?
	for (i = height-1;i>=0;i--)
    {

		//?
		for (j=0;j<width;j++)
		{
			// ?????i?,?j??????
			lpSrc = (unsigned char*)lpDIBBits + lLineBytes * i + j;

			//????????
			gray = *(lpSrc);

			//???????
			if (gray == 0)
			{
				//????,?????????????
				bottom = i;

				//?i?????????
				i=-1;

				//????
				break;
			}

          //????????,????
		}
	
	}

	//lab ???????????????
	bool lab = false;

	//??????????????
	bool black = false;

    //??????????
	RECT rect;

	//?????
//	digicount=0;
   
	//?
	for (i=0;i<width;i++)
	{
		//??????
		black=false;

		for (j=0;j<height;j++)
			{	
				// ?????i?,?j??????
				lpSrc = (unsigned char*)lpDIBBits + lLineBytes * j + i;

				//????????
				gray = *(lpSrc);

                //???????
				if (gray == 0)
				{
					//??????,?????
					black=true;

					//??????????????
					if(lab==false)
					{	
						//??????
						rect.left = i;

						//??????
						lab = true;
					}

					//???????????
					else

                      //????
						break;
				}		
			}

		//????????????,?????????????
           if(i==(width-1))
			   
		 //??????	   
		   break;

		//????black??false,???????,??????????????????
		if(lab==true&&black==false)
		{   
           //???????????

           //?????
			rect.right =i;

			//?????
			rect.top =top;

			//?????
			rect.bottom =bottom;

			//????????,??????
			::InflateRect(&rect,1,1);

            //?????????????????1???
			charRect1.push_back (rect);

			//?????,??????????
			lab=false;

			//??????????1
//			digicount++;
			
		}

		//????????

	}

   //?????????top?bottom???

	//???1?????2
	charRect2=charRect1;

    //???2?????
    charRect2.clear ();

	//????????????????
	RECT rectnew;

	//????1??????????
	while(!charRect1.empty())
	{    
		//???1????????
		rect= charRect1.front();

		//???1???????
		charRect1.pop_front();

		//???????????

		//????????
		rectnew.left =rect.left-1 ;

		//????????
		rectnew.right =rect.right+1 ;

		//????????????????????????

		// ???????????
		
		//?
		for(i=rect.top ;i<rect.bottom ;i++)
		{   
          //?
			for(j=rect.left ;j<rect.right ;j++)
			{   
                 // ?????i?,?j??????
				lpSrc = (unsigned char*)lpDIBBits + lLineBytes * i + j;

				//?????????
				if (*lpSrc == 0)
				{	
					//?????
					rectnew.top = i-1;
					
					//?i???????????
					i=rect.bottom  ;

					//????
					break;
				}	
			}
		}

		//???????????
   
        //?
		for(i=rect.bottom-1 ;i>=rect.top  ;i--)
		{
			//?
			for(j=rect.left ;j<rect.right ;j++)
			{
				// ?????i?,?j??????
				lpSrc = (unsigned char*)lpDIBBits + lLineBytes * i + j;

				//???????
				if (*lpSrc == 0)
				{	
					//?????
					rectnew.bottom = i+1;

                    //?i???????????
					i=-1;
                    //????
					break;
				}	
			}
		}

		//????????????????????2???
		charRect2.push_back (rectnew);
	}

	//???2 ?????1
	charRect1=charRect2;

	//????
	::GlobalUnlock(hDIB);
	
	g_CharSegmentRet.push_back(charRect1);
	//???1??
	LONG lngRet=g_CharSegmentRet.size()-1;
	return lngRet;
}

/****************************************************************
* ????:
*      Convert256toGray()
*
* ??:
*     HDIB hDIB     -?????
*
*  ???:
*        ?
*
*  ??:
*     ?256?????????
*
***************************************************************/

ANNRECOGNITION_API void Convert256toGray(HDIB hDIB)
{
	LPSTR	lpDIB;
	
	// ?DIB????DIB?????DIB
	lpDIB = (LPSTR) ::GlobalLock((HGLOBAL)hDIB);
	
	WORD wNumColors;	
	wNumColors = ::DIBNumColors((char*)lpDIB);	

	if(wNumColors!=256)
	{
		::GlobalUnlock ((HGLOBAL)hDIB);
		return;
	}

	// ??DIB????????
	LPSTR   lpDIBBits;	

	// ??DIB?????
	BYTE *	lpSrc;	

	// ????
	LONG	lWidth;	
	// ????
	LONG  	lHeight;	

	// ????????
	LONG	lLineBytes;	

	// ??BITMAPINFO?????(Win3.0)
	LPBITMAPINFO lpbmi;	

	// ??BITMAPCOREINFO?????
	LPBITMAPCOREINFO lpbmc;
	
	// ????BITMAPINFO?????(Win3.0)
	lpbmi = (LPBITMAPINFO)lpDIB;	

	// ????BITMAPCOREINFO?????
	lpbmc = (LPBITMAPCOREINFO)lpDIB;	

	// ?????
	BYTE bMap[256];
	
	// ???????(??????????),???DIB???
	int	i,j;
	for (i = 0; i < 256; i ++)
	{
		// ???????????
		bMap[i] = (BYTE)(0.299 * lpbmi->bmiColors[i].rgbRed +

					     0.587 * lpbmi->bmiColors[i].rgbGreen +

				         0.114 * lpbmi->bmiColors[i].rgbBlue + 0.5);			
		// ??DIB???????
		lpbmi->bmiColors[i].rgbRed = i;	
		
		// ??DIB???????
		lpbmi->bmiColors[i].rgbGreen = i;	
		
		// ??DIB???????
		lpbmi->bmiColors[i].rgbBlue = i;
			
		// ??DIB??????
		lpbmi->bmiColors[i].rgbReserved = 0;

	}
	// ??DIB????????
	lpDIBBits = ::FindDIBBits(lpDIB);
		
	// ??????
	lWidth = ::DIBWidth(lpDIB);	

	// ??????
	lHeight = ::DIBHeight(lpDIB);	

	// ??????????
	lLineBytes = WIDTHBYTES(lWidth * 8);	

	// ???????????(?????????????)

	//????
	for(i = 0; i < lHeight; i++)
	{
		  //????
		for(j = 0; j < lWidth; j++)
		{
			// ??DIB?i?,?j??????
			lpSrc = (unsigned char*)lpDIBBits + lLineBytes * (lHeight - 1 - i) + j;
					
			// ??
			*lpSrc = bMap[*lpSrc];
		}
	}

	//????
	::GlobalUnlock ((HGLOBAL)hDIB);
}

/******************************************************************
*
* ????ConvertGrayToWhiteBlack()
*
* ?? :HDIB hDIB     -?????
*
* ???:?
*
* ??: ConvertGrayToWhiteBlack??????????,????????????
* 
* ??:
?????????256?
************************************************************************/

ANNRECOGNITION_API void ConvertGrayToWhiteBlack(HDIB hDIB)
{
	// ??DIB???
	LPSTR	lpDIB;
	
	// ?DIB????DIB?????DIB
	lpDIB = (LPSTR) ::GlobalLock((HGLOBAL)hDIB);
	
	WORD wNumColors;	
	wNumColors = ::DIBNumColors((char*)lpDIB);	
	
	if(wNumColors!=256)
	{
		::GlobalUnlock ((HGLOBAL)hDIB);
		return;
	}

	// ??DIB????????
	LPSTR   lpDIBBits;
	
	// ??DIB?????
	BYTE *	lpSrc;	

	// ????
	LONG	lWidth;	

	// ????
	LONG	lHeight;	
	// ????????
	LONG	lLineBytes;	

	// ??DIB????????
	lpDIBBits = ::FindDIBBits(lpDIB);	
	
	// ??????
	lWidth = ::DIBWidth(lpDIB);	

	// ??????
	lHeight = ::DIBHeight(lpDIB);	

	// ??????????
	lLineBytes = WIDTHBYTES(lWidth * 8);	

	// ???????????(?????????????)
	int i,j;

    //????
	for(i = 0; i < lHeight; i++)
	{

	   //????
		for(j = 0; j < lWidth; j++)
		{

			// ??DIB?i?,?j??????
			lpSrc = (unsigned char*)lpDIBBits + lLineBytes * i + j;

			// ?????

		    //??220,???255,???
			if(*lpSrc>220) *lpSrc=255;

		    //?????0,???
			else *lpSrc=0;

		}

	}
	
	 //????
	::GlobalUnlock((HGLOBAL)hDIB);
}

/*****************************************************************
*
*  ???? 
*       DeleteScaterJudge()
*
*  ??:
*     LPSTR   lpDIBBits      -???????????
*	  WORD    lLineBytes     -????????
*     LPBYTE  lplab          -?????
*     int     lWidth         -?????
*	  int     lHeight        -?????
*     int     x              -???????
*	  int     y              -??????? 
*     CPoint  lab[]          -????????????
*     int     lianXuShu      -????????
*
*  ???:
*     Bool                   -??????false ???????true
*	 
*  ??:
*     ??????????????,?????????????
*
*  ??:
*     ???2???????
******************************************************************/     


ANNRECOGNITION_API bool DeleteScaterJudge(LPSTR lpDIBBits, WORD lLineBytes, LPBYTE lplab, int lWidth, int lHeight, int x, int y, POINT lab[], int lianXuShu)
{

	//??????????,???????,??
	if(m_lianXuShu>=lianXuShu)
		return TRUE;

	//????
	m_lianXuShu++;

	//??????
	lplab[lWidth * y +x] = true;
	
	//???????
	lab[m_lianXuShu-1].x = x;
	lab[m_lianXuShu-1].y = y;

	//??????
	int gray;
  
	//???????
	LPSTR lpSrc;

	//????
    //??????????,???????,??
	if(m_lianXuShu>=lianXuShu)
		return TRUE;
	
	//??????
	else
	{	
		//???????????????????????
		//??????,???????????

		//?????
		
		lpSrc=(char*)lpDIBBits + lLineBytes * (y-1) + x;

		//?????
		gray=*lpSrc;

		//?????????????????????
		if(y-1 >=0 && gray == 0 && lplab[(y-1)*lWidth+x] == false)

		//??????		
		DeleteScaterJudge(lpDIBBits,lLineBytes,lplab,lWidth,lHeight,x,y-1,lab,lianXuShu);

		//????
		//??????????,???????,??
		if(m_lianXuShu>=lianXuShu)
		return TRUE;
		
		//???
		
		lpSrc=(char*)lpDIBBits + lLineBytes * (y-1) + x-1;

        //?????
		gray=*lpSrc;

        //?????????????????????
		if(y-1 >=0 &&  x-1 >=0 && gray== 0 && lplab[(y-1)*lWidth+x-1] == false)

      	//??????		
		DeleteScaterJudge(lpDIBBits,lLineBytes,lplab,lWidth,lHeight,x-1,y-1,lab,lianXuShu);

        //????
		//??????????,???????,??
		if(m_lianXuShu>=lianXuShu)
		return TRUE;
		
		//??
		
		lpSrc=(char*)lpDIBBits + lLineBytes * y + x-1;

		//?????
		gray=*lpSrc;

        //?????????????????????
		if(x-1 >=0 &&  gray== 0 && lplab[y*lWidth+x-1] == false)

        //??????		
		DeleteScaterJudge(lpDIBBits,lLineBytes,lplab,lWidth,lHeight,x-1,y,lab,lianXuShu);

        //????
		//??????????,???????,??
		if(m_lianXuShu>=lianXuShu)
			return TRUE;
		
		//??
		
		lpSrc=(char*)lpDIBBits + lLineBytes * (y+1) + x-1;

		//?????
		gray=*lpSrc;

        //?????????????????????
		if(y+1 <lHeight && x-1 >= 0 && gray == 0 && lplab[(y+1)*lWidth+x-1] == false)

		//??????
		
		DeleteScaterJudge(lpDIBBits,lLineBytes,lplab,lWidth,lHeight,x-1,y+1,lab,lianXuShu);

        //????
		//??????????,???????,??
		if(m_lianXuShu>=lianXuShu)
			return TRUE;
		
		//??
		
		lpSrc=(char*)lpDIBBits + lLineBytes * (y+1) + x;

        //?????
		gray=*lpSrc;

        //?????????????????????
		if(y+1 < lHeight && gray == 0 && lplab[(y+1)*lWidth+x] == false)

        //??????
		
		DeleteScaterJudge(lpDIBBits,lLineBytes,lplab,lWidth,lHeight,x,y+1,lab,lianXuShu);

        //????
		//??????????,???????,??
		if(m_lianXuShu>=lianXuShu)
			return TRUE;
		
		//??
		
		lpSrc=(char*)lpDIBBits + lLineBytes * (y+1) + x+1;
        
		//?????
		gray=*lpSrc;

        //?????????????????????
		if(y+1 <lHeight && x+1 <lWidth &&  gray == 0 && lplab[(y+1)*lWidth+x+1] == false)

        //??????
		DeleteScaterJudge(lpDIBBits,lLineBytes,lplab,lWidth,lHeight,x+1,y+1,lab,lianXuShu);

        //????
		//??????????,???????,??
		if(m_lianXuShu>=lianXuShu)
			return TRUE;
		
		//??
	
		lpSrc=(char*)lpDIBBits + lLineBytes * y + x+1;

        //?????
		gray=*lpSrc;

		//?????????????????????
		if(x+1 <lWidth && gray==0 && lplab[y*lWidth+x+1] == false)

        //??????		
		DeleteScaterJudge(lpDIBBits,lLineBytes,lplab,lWidth,lHeight,x+1,y,lab,lianXuShu);

        //????

		//??????????,???????,??
		if(m_lianXuShu>=lianXuShu)
			return TRUE;
		
		//??
		
		lpSrc=(char*)lpDIBBits + lLineBytes * (y-1) + x+1;

        //?????
		gray=*lpSrc;

        //?????????????????????
		if(y-1 >=0 && x+1 <lWidth && gray == 0 && lplab[(y-1)*lWidth+x+1] == false)

       //??????		
	   DeleteScaterJudge(lpDIBBits,lLineBytes,lplab,lWidth,lHeight,x+1,y-1,lab,lianXuShu);

        //????
		//??????????,???????,??
		if(m_lianXuShu>=lianXuShu)
			return TRUE;
	}
	

	//??????,??false,??????
	return FALSE;

}


/*****************????????????*******************/
ANNRECOGNITION_API void DrawFrame(HDC pDC,HDIB hDIB, LONG charRectID,unsigned int linewidth,COLORREF color)
{	
	if(charRectID>=g_CharSegmentRet.size()) return ;

	CRectLink charRect= g_CharSegmentRet[charRectID];

	CPen pen;
	pen.CreatePen (PS_SOLID,linewidth,color);

	CDC tempDC;
	tempDC.Attach(pDC);
	tempDC.SelectPen ((HPEN)pen);
	
	::SelectObject (pDC,GetStockObject(NULL_BRUSH));
	RECT rect,rect2;
	BYTE* lpDIB=(BYTE*)::GlobalLock ((HGLOBAL)hDIB);
	while(!charRect.empty())
	{
		
		//??????????
		rect2=rect= charRect.front();
		//??????????
		charRect.pop_front();
		//??,?????rect????????(???)?,
		//????????,?????????????
		rect.top =::DIBHeight ((char*)lpDIB)-rect2.bottom;
		rect.bottom =::DIBHeight ((char*)lpDIB)-rect2.top ;
		tempDC.Rectangle(&rect);
	}
	
	tempDC.Detach();

	::GlobalUnlock ((HGLOBAL)hDIB);
}
/***********************************************
*
* ????:
*   GradientSharp() 
*
*?? :
*  HDIB hDIB    -????????
*
* ???:
*       ?
* 
*??:
*    ????????

*??:
*    ???2???????,??????????,?????????
**********************************************************************/
ANNRECOGNITION_API void GradientSharp(HDIB hDIB)
{
	// ??DIB???
	LPSTR lpDIB=(LPSTR) ::GlobalLock((HGLOBAL)hDIB);

	// ??DIB????
	LPSTR    lpDIBBits;	

	// ??DIB????????
	lpDIBBits = ::FindDIBBits(lpDIB);	

    //???????
	LONG lWidth=::DIBWidth ((char*)lpDIB);

    //???????
	LONG lHeight=::DIBHeight ((char*)lpDIB);

    // ??
	BYTE	bThre = 2;

	// ??GradSharp()?????????

	// ????????
	unsigned char*	lpSrc;
	unsigned char*	lpSrc1;
	unsigned char*	lpSrc2;
	
	// ????
	LONG	i;
	LONG	j;
	
	// ????????
	LONG	lLineBytes;
	
	// ????
	BYTE	bTemp;
	
	// ??????????
	lLineBytes = WIDTHBYTES(lWidth * 8);
	
	// ??
   for(i = 0; i < lHeight; i++)
	{
		
     // ??
	 for(j = 0; j < lWidth; j++)
		{
			
             // ??DIB?i?,?j??????
			lpSrc  = (unsigned char*)lpDIBBits + lLineBytes * (lHeight - 1 - i) + j;
			
			// ??DIB?i+1?,?j??????
			lpSrc1 = (unsigned char*)lpDIBBits + lLineBytes * (lHeight - 2 - i) + j;
			
		     // ??DIB?i?,?j+1??????
		     lpSrc2 = (unsigned char*)lpDIBBits + lLineBytes * (lHeight - 1 - i) + j + 1;
			

              //?????
		     bTemp = abs((*lpSrc)-(*lpSrc1)) + abs((*lpSrc)-(*lpSrc2));
			
		    // ????????
		    if (bTemp < 255)
			{  

		     // ????????,??????,??????
			   if (bTemp >= bThre)
			   {

			// ?????bTemp
			 *lpSrc = bTemp;

			   }

			}
			
           else
			{
				// ?????255
				*lpSrc = 255;
			}
	 }
   }

	//????????????????
	for(j = 0; j < lWidth; j++)
	{   
		
	 //???????,?j??????
	  lpSrc  = (unsigned char*)lpDIBBits + lLineBytes * 0 + j;

	   //??????????255,???
		*lpSrc=255;
	}

   //????
	::GlobalUnlock ((HGLOBAL)hDIB);
}


/************************************************************
*
*  ????:
*       RemoveScatterNoise()
*
*  ??:
*     HDIB    hDIB     -??????
*
*  ???:
*       ?
*
*  ??:
*     ??????????????????
*
*  ??:
*      ???2???????
****************************************************************/
ANNRECOGNITION_API void RemoveScatterNoise(HDIB hDIB)
{
	
	// ??DIB???
	LPSTR lpDIB=(LPSTR) ::GlobalLock((HGLOBAL)hDIB);
	

	// ??DIB????
	LPSTR    lpDIBBits;	

	// ??DIB????????????
	lpDIBBits = ::FindDIBBits(lpDIB);
	
	//???????
	LONG lWidth=::DIBWidth ((char*)lpDIB);

	//???????
	LONG lHeight=::DIBHeight ((char*)lpDIB);

	//????????????15
	//??????????????????15??????????
	int length=15;
		

	// ????
	m_lianXuShu=0;
	LONG	i;
	LONG	j;	
	LONG    k;

	// ????????
	LONG	lLineBytes;

	// ??????????
	lLineBytes = WIDTHBYTES(lWidth * 8);

    
	LPSTR lpSrc;

	//???????????????
	LPBYTE lplab = new BYTE[lHeight * lWidth];

	//???????????????????
	bool *lpTemp = new bool[lHeight * lWidth];

    //???????
	for (i=0;i<lHeight*lWidth;i++)
    {

		//???????????
		lplab[i] = false;

	}

	//?????????????
	POINT lab[21];
   
	//?????????
	k=0;

	//??????

	//????
	for(i =0;i<lHeight;i++)
	{  
       
	   //????
		for(j=0;j<lWidth;j++)
			{	
				//??????false
				for(k=0;k<m_lianXuShu;k++)
				lplab[lab[k].y * lWidth + lab[k].x] = false;

				//????0
				m_lianXuShu =0;

			    //???????
			    lpTemp[i*lWidth+j] = DeleteScaterJudge(lpDIBBits,(WORD)lLineBytes,lplab,lWidth,lHeight,j,i,lab,length);

			}
	}
			
	//??????,?????????

	//????
	for(i = 0;i<lHeight;i++)
	{

      //????
		for(j=0;j<lWidth;j++)
		{       
			    //?????,????????????
				if(lpTemp[i*lWidth+j] == false)
				{	
                   //???i??j??????
					lpSrc=(char*)lpDIBBits + lLineBytes * i + j;

					//????????
					*lpSrc=BYTE(255);
				}
			}
	}

	//????
	::GlobalUnlock ((HGLOBAL)hDIB);

}

/*********************************************************

* ????:
*         SlopeAdjust()
*
* ??:
*     HDIB   hDIB       -??????
*
* ???:
*         ?
*
* ??:
*     ????????????????????????
*
* ??:
*      ???2???????
*
****************************************************************/
ANNRECOGNITION_API void SlopeAdjust(HDIB hDIB)
{
	// ??DIB???
	LPSTR lpDIB=(LPSTR) ::GlobalLock((HGLOBAL)hDIB);
	
	// ??DIB????
	LPSTR    lpDIBBits;	

	// ??DIB????????
	lpDIBBits = ::FindDIBBits(lpDIB);
	
	// ????????
	unsigned char*	lpSrc;

	// ????
	LONG	i;
	LONG	j;
	
	// ????????
	LONG	lLineBytes;

	//?????
	LONG    lWidth;

	//?????
	LONG	lHeight;

	//???????
	lWidth=::DIBWidth ((char*)lpDIB);

	//???????
	lHeight=::DIBHeight ((char*)lpDIB);

	// ??????????
	lLineBytes = WIDTHBYTES(lWidth * 8);
    
	//??????????
	double leftaver=0.0;

   //??????????
	double rightaver=0.0;

	//??????
	double slope;

	//??????
	LONG counts=0;
	
	//????????,??????????

	//?
	for (i=0;i<lHeight;i++)
	{   

      //?
		for (j=0;j<lWidth/2;j++)
		{
		 
		 //???i??j??????	
		 lpSrc=(unsigned char*)lpDIBBits + lLineBytes *  i + j;
      
		 //?????
		 if (*lpSrc == 0)
		 {
          
          //??????????
		  counts +=lWidth/2 -j;
		  leftaver += i*(lWidth/2 -j);

		 }

		}
	}

    //??????
	leftaver /= counts;
	
	//???????????
	counts =0;

	//????????,??????????

	//?
	for (i =0;i<lHeight;i++)
	{

       //?
		for (j=lWidth/2;j<lWidth;j++)
		{
			//???i??j??????
			lpSrc=(unsigned char*)lpDIBBits + lLineBytes *  i + j;

            //?????
			if (*lpSrc == 0)
				{

				  //??????
					counts +=lWidth -j;
					rightaver += i*(lWidth -j);
				}
			}
	}

	//??????????
	rightaver /= counts;
	
	//????
	slope = (leftaver - rightaver) / (lWidth/2);

	//???????????????
	LPSTR lpNewDIBBits;
   
	//????????
	LPSTR lpDst;
    
	//??????
	HLOCAL nNewDIBBits=LocalAlloc(LHND,lLineBytes*lHeight);
    
	//????
	lpNewDIBBits=(char*)LocalLock(nNewDIBBits);
    
	//??????????
	lpDst=(char*)lpNewDIBBits;
    
	//????????
	memset(lpDst,(BYTE)255,lLineBytes*lHeight);
    
	//???????
	int gray;
    
	//?????
	int i_src;

	//????,????????????????

	//?
	for (i=0;i<lHeight;i++)
	{
		//?
   		for (j=0;j<lWidth;j++)
		{	
		   //??????	
			i_src=int(i - (j-lWidth/2)*slope);

			//???????,?????
			if (i_src <0 || i_src >=lHeight )
				gray = 255;

			else
			{	
				//?????????,?????

				//???i_src??j??????
				lpSrc=(unsigned char *)lpDIBBits + lLineBytes *  i_src + j;
				gray = *lpSrc;
			}
			
			//???????????????
            //???i??j??????
			lpDst = (char *)lpNewDIBBits + lLineBytes * i + j;
			*lpDst=gray;
		}
	}

	// ????????????????
	memcpy(lpDIBBits,lpNewDIBBits,lLineBytes*lHeight);

   // ????
	::GlobalUnlock ((HGLOBAL)hDIB);
}



/******************************************************************
*
*  ????:
*      StdDIBbyRect()
*
*  ??:
*     HDIB  hDIB          -?????
*     int   tarWidth      -??????
*     int   tarHeight     -??????
*
*  ???:
*         ?
*
*  ??:
*     ????????,???????????????,????????
*
*  ??:
*     ??????,?????????,???????????????????????
*
******************************************************************/
ANNRECOGNITION_API void StdDIBbyRect(HDIB hDIB,LONG charRectID,int tarWidth, int tarHeight)
{	
	if(charRectID>=g_CharSegmentRet.size()) return ;
	CRectLink & m_charRect=g_CharSegmentRet[charRectID];

	//???????
	BYTE* lpDIB=(BYTE*)::GlobalLock ((HGLOBAL)hDIB);

	//???????????
	BYTE* lpDIBBits=(BYTE*)::FindDIBBits ((char*)lpDIB);
	
	//???????
	BYTE* lpSrc;

	//????????
	LONG lWidth=::DIBWidth ((char*)lpDIB);

	//???????
	LONG lHeight=::DIBHeight ((char*)lpDIB);

	// ????
	int	i;
	int	j;
	
	// ????????
	LONG	lLineBytes = WIDTHBYTES(lWidth * 8);

	//?????????????
	double wscale,hscale;

	//?????????,???????????
	LPSTR lpNewDIBBits;
	LPSTR lpDst;
 
    //??????????????????
	HLOCAL nNewDIBBits=LocalAlloc(LHND,lLineBytes*lHeight);

	//????????????
	lpNewDIBBits=(char*)LocalLock(nNewDIBBits);

	//??????????
	lpDst=(char*)lpNewDIBBits;

	//???????????
	memset(lpDst,(BYTE)255,lLineBytes*lHeight);

	//???????????
	int i_src,j_src;

	//????????????
	RECT rect;
	RECT rectnew;

	//????????????????????????????
	CRectLink m_charRectCopy;

	//????????????
	while(!m_charRect.empty())
	{
		//??????????
		rect= m_charRect.front();

		//??????????
		m_charRect.pop_front();

		//??????

		//??????????
		wscale=(double)tarWidth/RECTWIDTH(&rect);

		//??????????
		hscale=(double)tarHeight/RECTHEIGHT(&rect);

		//???????

		//???
		rectnew.top =rect.top ;

		//???
		rectnew.bottom =rect.top +tarHeight;

		//???
		rectnew.left =rect.left ;

		//???
		rectnew.right =rectnew.left +tarWidth;

		//??????????????????
		for(i=rectnew.top ;i<rectnew.bottom ;i++)
		{
			for(j=rectnew.left ;j<rectnew.right ;j++)
			{   

				//??????
				i_src=rectnew.top +int((i-rectnew.top )/hscale);
				j_src=rectnew.left +int((j-rectnew.left )/wscale);

				//??????????????
				lpSrc=(unsigned char *)lpDIBBits + lLineBytes *  i_src + j_src;
				lpDst = (char *)lpNewDIBBits + lLineBytes * i + j;
				*lpDst=*lpSrc;
			}
		}
		//????????????????
		m_charRectCopy.push_back (rectnew);

	
	}

	//????????rect??
    m_charRect=m_charRectCopy;

	//?????????????????
	memcpy(lpDIBBits,lpNewDIBBits,lLineBytes*lHeight);

	//????
	::GlobalUnlock ((HGLOBAL)hDIB);
}

ANNRECOGNITION_API void StdDIB(HDIB hDIB,int tarWidth, int tarHeight)
{	

	//???????
	BYTE* lpDIB=(BYTE*)::GlobalLock ((HGLOBAL)hDIB);

	//???????????
	BYTE* lpDIBBits=(BYTE*)::FindDIBBits ((char*)lpDIB);
	
	//???????
	BYTE* lpSrc;

	//????????
	LONG lWidth=::DIBWidth ((char*)lpDIB);

	//???????
	LONG lHeight=::DIBHeight ((char*)lpDIB);

	// ????
	int	i;
	int	j;
	
	// ????????
	LONG	lLineBytes = WIDTHBYTES(lWidth * 8);

	//?????????????
	double wscale,hscale;

	//?????????,???????????
	LPSTR lpNewDIBBits;
	LPSTR lpDst;
 
    //??????????????????
	HLOCAL nNewDIBBits=LocalAlloc(LHND,lLineBytes*lHeight);

	//????????????
	lpNewDIBBits=(char*)LocalLock(nNewDIBBits);

	//??????????
	lpDst=(char*)lpNewDIBBits;

	//???????????
	memset(lpDst,(BYTE)255,lLineBytes*lHeight);

	//???????????
	int i_src,j_src;

	//????????????
	RECT rect;
	RECT rectnew;

	//??????????
	rect.top=0;
	rect.left=0;
	rect.right=lWidth;
	rect.bottom=lHeight;

		
	//??????

	//??????????
	wscale=(double)tarWidth/RECTWIDTH(&rect);

	//??????????
	hscale=(double)tarHeight/RECTHEIGHT(&rect);

	//???????

	//???
	rectnew.top =rect.top ;

	//???
	rectnew.bottom =rect.top +tarHeight;

	//???
	rectnew.left =rect.left ;

	//???
	rectnew.right =rectnew.left +tarWidth;

	//??????????????????
	for(i=rectnew.top ;i<rectnew.bottom ;i++)
	{
		for(j=rectnew.left ;j<rectnew.right ;j++)
		{   

			//??????
			i_src=rectnew.top +int((i-rectnew.top )/hscale);
			j_src=rectnew.left +int((j-rectnew.left )/wscale);

			//??????????????
			lpSrc=(unsigned char *)lpDIBBits + lLineBytes *  i_src + j_src;
			lpDst = (char *)lpNewDIBBits + lLineBytes * i + j;
			*lpDst=*lpSrc;
		}
	}

	//?????????????????
	memcpy(lpDIBBits,lpNewDIBBits,lLineBytes*lHeight);

	//????
	::GlobalUnlock ((HGLOBAL)hDIB);
}


ANNRECOGNITION_API  void Thinning(HDIB hDIB)
{
	// ??DIB???
	LPSTR lpDIB=(LPSTR) ::GlobalLock((HGLOBAL)hDIB);
	
	// ??DIB????
	LPSTR    lpDIBBits;	

	// ??DIB????????
	lpDIBBits = ::FindDIBBits(lpDIB);	
	
	// ????????
	LPSTR	lpSrc;

	//????????
	LONG lWidth;
	LONG lHeight;

	//???????
	lWidth=::DIBWidth ((char*)lpDIB);

	//???????
	lHeight=::DIBHeight ((char*)lpDIB);

    //????????
    LONG  lLineBytes = (lWidth+3)*4/4;

	//????
    int i,j;

    //???????2???
	BYTE *image = (BYTE*)malloc(lWidth*lHeight*sizeof(BYTE));

	//?2?????

	for(i=0;i<lHeight;i++)
	{
	    for(j=0;j<lWidth;j++)
		{
	      lpSrc=lpDIBBits+i*lLineBytes+j;
	    
	      if(*lpSrc==0)
	      image[i*lWidth+j]=1;

		  else
         image[i*lWidth+j]=0;
		}
	}

   //????????,????????

   ThinnerRosenfeld(image,lHeight,lWidth);

   //ThinnerHilditch(image,lHeight,lWidth);



   //??????????

   for(i=0;i<lHeight;i++)
   {
     for(j=0;j<lWidth;j++)
	 {
	   lpSrc=lpDIBBits+i*lLineBytes+j;

       if(image[i*lWidth+j]==1)
	   *lpSrc=(BYTE)0;

	   else
       *lpSrc=(BYTE)255;
	 }
   
   }


 //????
   free(image);
   ::GlobalUnlock ((HGLOBAL)hDIB);

	return;
}

/*****************************************************
* 
*   ????:
*      Template:
*
*    ??:
*	   HDIB    hDIB         -?????
*      double  *tem         -???????
*      int  tem_w           -?????
*      int  tem_h           -?????
*      double xishu         -?????
*         
*    ??:
*	   ?????????
*
*    ??:
*	   ???????,?????????????
*******************************************************/
ANNRECOGNITION_API  HDIB Template(HDIB hDIB,double * tem ,int tem_w,int tem_h,double xishu)
{

    //?????
    double sum;

    //???????????
    BYTE *lpDIB=(BYTE*)::GlobalLock((HGLOBAL) hDIB);

	//???????????
	BYTE *pScrBuff =(BYTE*)::FindDIBBits((char*)lpDIB);
   
	//?????????
    int numColors=(int) ::DIBNumColors((char *)lpDIB);

    //??????256???
     if (numColors!=256) 
	 {   
        //????
	  	::GlobalUnlock((HGLOBAL) hDIB);

		//??
		return(hDIB);
	 }
    
    //??????????????,???????
    BYTE* oldbuf = pScrBuff;

    //????
    int i,j,m,n;

	int w, h, dw;

	//???????
	w = (int) ::DIBWidth((char *)lpDIB);
	
	//???????
	h = (int) ::DIBHeight((char *)lpDIB);
	
	//??????????
	dw = (w+3)/4*4;      
	
	//?????????????25?????
    HDIB newhDIB=NewDIB(w,h,8);  
    
	//?????????
	BYTE *newlpDIB=(BYTE*)::GlobalLock((HGLOBAL) newhDIB);

	//???????????????? 
    BYTE *destBuf = (BYTE*)FindDIBBits((char *)newlpDIB);
    
   //???????????????,???????
    BYTE *newbuf=destBuf; 
	
	//???????
   
	//? 
    for(i=0;i<h;i++)
    {  
		//?
	   for(j=0;j<w;j++)
	   {   

		   //?????????
	       sum=0;

         //?????4?????????????
	     if( j<((tem_w-1)/2) || j>(w-(tem_w+1)/2) || i<((tem_h-1)/2) || i>(h-(tem_h+1)/2) )
	      *(newbuf+i*dw+j)=*(oldbuf+i*dw+j);
		 
         //?????????????
		 else 
         { 

          //??(i,j)????????
          for(m=i-((tem_h-1)/2);m<=i+((tem_h-1)/2);m++)
          {
		     for(n=j-((tem_w-1)/2);n<=j+((tem_w-1)/2);n++)
		    
             //???(i,j)???,????????????????????????
			 //?????????
		     sum+=*(oldbuf+m*dw+n)* tem[(m-i+((tem_h-1)/2))*tem_w+n-j+((tem_w-1)/2)];
		  
		  }
          
		  //???????????
          sum=(int)sum*xishu;

		  //?????
		  sum = fabs(sum);

		  //????0,?????0
          if(sum<0)     
          sum=0;

		  //????255,?????255
          if(sum>255)
		  sum=255;

		  //?????????????????
	      *(newbuf+i*dw+j)=sum;
		 }
	   }
	} 
   
	//????
	::GlobalUnlock((HGLOBAL)hDIB);
    
	//?????????
    return(newhDIB);
}
/*****************************************************
* 
*   ????:
*      Template:
*
*    ??:
*	   HDIB    hDIB         -?????
*      int  tem_w           -?????
*      int  tem_h           -?????
*      
*    ??:
*	   ???????
*
*    ??:
*	   ???????,?????????????
*******************************************************/

ANNRECOGNITION_API HDIB MidFilter(HDIB hDIB,int tem_w,int tem_h)
{

    //?????
    double mid;

	BYTE *temp=(BYTE*)malloc(tem_w*tem_h*sizeof(BYTE));

    //???????????
    BYTE *lpDIB=(BYTE*)::GlobalLock((HGLOBAL) hDIB);

	//???????????
	BYTE *pScrBuff =(BYTE*)::FindDIBBits((char*)lpDIB);
   
	//?????????
    int numColors=(int) ::DIBNumColors((char *)lpDIB);

    //??????256???
     if (numColors!=256) 
	 {   
        //????
	  	::GlobalUnlock((HGLOBAL) hDIB);

		//??
		return(hDIB);
	 }
    
    //??????????????,???????
    BYTE* oldbuf = pScrBuff;

    //????
    int i,j,m,n;

	int w, h, dw;

	//???????
	w = (int) ::DIBWidth((char *)lpDIB);
	
	//???????
	h = (int) ::DIBHeight((char *)lpDIB);
	
	//??????????
	dw = (w+3)/4*4;      
	
	//?????????????25?????
    HDIB newhDIB=NewDIB(w,h,8);  
    
	//?????????
	BYTE *newlpDIB=(BYTE*)::GlobalLock((HGLOBAL) newhDIB);

	//???????????????? 
    BYTE *destBuf = (BYTE*)FindDIBBits((char *)newlpDIB);
    
   //???????????????,???????
    BYTE *newbuf=destBuf; 
	
	//???????
   
	//? 
    for(i=0;i<h;i++)
    {  
		//?
	   for(j=0;j<w;j++)
	   {   

		   //?????????
	       

         //?????4?????????????
	     if( j<((tem_w-1)/2) || j>(w-(tem_w+1)/2) || i<((tem_h-1)/2) || i>(h-(tem_h+1)/2) )
	      *(newbuf+i*dw+j)=*(oldbuf+i*dw+j);
		 
         //?????????????
		 else 
         { 

          //??(i,j)????????
          for(m=i-((tem_h-1)/2);m<=i+((tem_h-1)/2);m++)
          {
		     for(n=j-((tem_w-1)/2);n<=j+((tem_w-1)/2);n++)
		    
             //???(i,j)???,??????????????????????
		     temp[(m-i+((tem_h-1)/2))*tem_w+n-j+((tem_w-1)/2)]=*(oldbuf+m*dw+n);
		  
		  }
          
		 //?????????
           for(m=0;m<tem_w*tem_h-1;m++)
           {
		   
		      for(n=0;n<tem_w*tem_h-m-1;n++)
			  {
			    if(temp[n]>temp[n+1]) 
			    mid=temp[n];
                temp[n]=temp[n+1];
			    temp[n+1]=mid;
			  }
		   
		   } 

           //?????????????????
	      *(newbuf+i*dw+j)=temp[(tem_w*tem_h-1)/2];
		 }
	   }
	} 
   
	//????
	::GlobalUnlock((HGLOBAL)hDIB);
    
	//?????????
    return(newhDIB);
}



/*************************************************************************
 *
 * ????:
 *   Equalize()
 *
 * ??:
 *   HDIB hDIB
 *
 *
 * ??:
 *   ????????????????
 *
 ************************************************************************/
ANNRECOGNITION_API void Equalize(HDIB hDIB)
{
	BYTE* lpDIB=(BYTE*)::GlobalLock ((HGLOBAL)hDIB);
	BYTE* lpDIBBits=(BYTE*)::FindDIBBits((char*)lpDIB);
	LONG lHeight=::DIBHeight ((char*)lpDIB);
	LONG lWidth=::DIBWidth ((char*)lpDIB);
	// ????????
	unsigned char*	lpSrc;
	
	// ????
	LONG	lTemp;
	
	// ????
	LONG	i;
	LONG	j;
	
	// ?????
	BYTE	bMap[256];
	
	// ?????
	LONG	lCount[256];
	
	// ????????
	LONG	lLineBytes;
	
	// ??????????
	lLineBytes = WIDTHBYTES(lWidth * 8);
	
	// ?????0
	for (i = 0; i < 256; i ++)
	{
		// ??
		lCount[i] = 0;
	}
	
	// ??????????
	for (i = 0; i < lHeight; i ++)
	{
		for (j = 0; j < lWidth; j ++)
		{
			lpSrc = (unsigned char *)lpDIBBits + lLineBytes * i + j;
			
			// ???1
			lCount[*(lpSrc)]++;
		}
	}
	
	// ???????
	for (i = 0; i < 256; i++)
	{
		// ???0
		lTemp = 0;
		
		for (j = 0; j <= i ; j++)
		{
			lTemp += lCount[j];
		}
		
		// ?????????
		bMap[i] = (BYTE) (lTemp * 255 / lHeight / lWidth);
	}
	
	// ??
	for(i = 0; i < lHeight; i++)
	{
		// ??
		for(j = 0; j < lWidth; j++)
		{
			// ??DIB?i?,?j??????
			lpSrc = (unsigned char*)lpDIBBits + lLineBytes * (lHeight - 1 - i) + j;
			
			// ???????
			*lpSrc = bMap[*lpSrc];
		}
	}
	
	::GlobalUnlock ((HGLOBAL)hDIB);
}

ANNRECOGNITION_API LONG	GetSegmentCount(LONG charRectID)
{
	if(charRectID>=g_CharSegmentRet.size()) return 0;
	return g_CharSegmentRet[charRectID].size();
}

ANNRECOGNITION_API void	SaveSegment(HDIB hInputDIB,LONG charRectID,LPSTR destFolder)
{
	if(charRectID>=g_CharSegmentRet.size()) return ;
	
	CRectLink m_charRect = g_CharSegmentRet[charRectID];
	CRectLink m_charRectCopy=m_charRect;
	
	int digicount=GetSegmentCount(charRectID);
	
	HDIBLink m_dibRect;
	HDIBLink m_dibRectCopy;

	unsigned char* lpSrc;
	int w,h;
	w=RECTWIDTH(&m_charRect.front ());
	h=RECTHEIGHT(&m_charRect.front ());
	
	int i_src,j_src;
	int i,j;
	int counts=0;
	RECT rect;
	BYTE* lpDIB=(BYTE*)::GlobalLock ((HGLOBAL)hInputDIB);
	BYTE* lpDIBBits=(BYTE*)::FindDIBBits ((char*)lpDIB);
	BYTE* lpNewDIBBits;
	BYTE* lpDst;
	LONG lLineBytes=(digicount*w+3)/4*4;
	LONG lLineBytesnew =(w+3)/4*4;
	HDIB hDIB=NULL;
	while(!m_charRect.empty ())
	{
		hDIB=::NewDIB (w,h,8);
		lpDIB=(BYTE*) ::GlobalLock((HGLOBAL)hDIB);	
		lpNewDIBBits = (BYTE*)::FindDIBBits((char*)lpDIB);
		lpDst=(BYTE*)lpNewDIBBits;
		memset(lpDst,(BYTE)255,lLineBytesnew * h);		
		rect=m_charRect.front ();
		m_charRect.pop_front ();
		for(i=0;i<h;i++)
			for(j=0;j<w;j++)
			{
				i_src=rect.top + i;
				j_src=j+counts*w;
				lpSrc=(BYTE *)lpDIBBits + lLineBytes *  i_src + j_src;
				lpDst=(BYTE *)lpNewDIBBits + lLineBytesnew * i + j;
				*lpDst=*lpSrc;
			}
			::GlobalUnlock (hDIB);
			m_dibRect.push_back (hDIB);
			counts++;
	}
	m_charRect=m_charRectCopy;
	m_dibRectCopy=m_dibRect;
	//???.bmp??
	counts=1;
	while(!m_dibRect.empty ())
	{
		char  str[256];
		sprintf(str,"%s\\part%d.bmp",destFolder,counts);
		::SaveDIB (m_dibRect.front (),str);
		m_dibRect.pop_front ();
		counts++;
	}
	m_dibRect=m_dibRectCopy;

}
