// ************************************************************************
//  ???:dibapi.cpp
//
//  ?? DIB(Independent Bitmap) API???:
//
//  PaintDIB()          - ??DIB??
//  FindDIBBits()       - ??DIB????????
//  DIBWidth()          - ??DIB??
//  DIBHeight()         - ??DIB??
//  DIBNumColors()      - ??DIB???????
//  CopyHandle()        - ?????
//
//  SaveDIB()           - ?DIB????????
//  ReadDIBFile()       - ????????DIB??
//  NewDIB()            - ????????????????????DIB
//
//  PaletteSize()       - ??DIB?????
//
// ************************************************************************



#include "stdafx.h"
#include "ANNRecognition.h"


/*************************************************************************
 *
 * ????:
 *   PaintDIB()
 *
 * ??:
 *   HDC hDC            - ????DC
 *   LPRECT lpDCRect    - ??????
 *   HDIB hDIB          - ??DIB?????
 *   LPRECT lpDIBRect   - ????DIB??
 *   CPalette* pPal     - ??DIB????????
 *
 * ???:
 *   BOOL               - ??????TRUE,????FALSE?
 *
 * ??:
 *   ?????????DIB????????StretchDIBits()??
 * SetDIBitsToDevice()???DIB????????????hDC?
 * ?;??????????lpDCRect??;??DIB??????
 * lpDIBRect???
 *
 ************************************************************************/

ANNRECOGNITION_API BOOL  PaintDIB(HDC     hDC,
					LPRECT  lpDCRect,
					HDIB    hDIB,
					LPRECT  lpDIBRect,
					CPalette* pPal)
{
	LPSTR    lpDIBHdr;            // BITMAPINFOHEADER??
	LPSTR    lpDIBBits;           // DIB????
	BOOL     bSuccess=FALSE;      // ????
	HPALETTE hPal=NULL;           // DIB???
	HPALETTE hOldPal=NULL;        // ??????

	// ??DIB??????
	if (hDIB == NULL)
	{
		// ??
		return FALSE;
	}

	// ??DIB
	lpDIBHdr  = (LPSTR) ::GlobalLock((HGLOBAL) hDIB);

	// ??DIB????????
	lpDIBBits = ::FindDIBBits(lpDIBHdr);

	// ??DIB???,????
	if (pPal != NULL)
	{
		hPal = (HPALETTE) pPal->m_hPalette;

		// ?????
		hOldPal = ::SelectPalette(hDC, hPal, TRUE);
	}

	// ??????
	::SetStretchBltMode(hDC, COLORONCOLOR);

	// ?????StretchDIBits()??SetDIBitsToDevice()???DIB??
	if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDIBRect)) &&
	   (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDIBRect)))
	{
		// ????,?????
		bSuccess = ::SetDIBitsToDevice(hDC,                    // hDC
								   lpDCRect->left,             // DestX
								   lpDCRect->top,              // DestY
								   RECTWIDTH(lpDCRect),        // nDestWidth
								   RECTHEIGHT(lpDCRect),       // nDestHeight
								   lpDIBRect->left,            // SrcX
								   (int)DIBHeight(lpDIBHdr) -
									  lpDIBRect->top -
									  RECTHEIGHT(lpDIBRect),   // SrcY
								   0,                          // nStartScan
								   (WORD)DIBHeight(lpDIBHdr),  // nNumScans
								   lpDIBBits,                  // lpBits
								   (LPBITMAPINFO)lpDIBHdr,     // lpBitsInfo
								   DIB_RGB_COLORS);            // wUsage
	}
    else
	{
		// ?????,???
		bSuccess = ::StretchDIBits(hDC,                          // hDC
							   lpDCRect->left,                 // DestX
							   lpDCRect->top,                  // DestY
							   RECTWIDTH(lpDCRect),            // nDestWidth
							   RECTHEIGHT(lpDCRect),           // nDestHeight
							   lpDIBRect->left,                // SrcX
							   lpDIBRect->top,                 // SrcY
							   RECTWIDTH(lpDIBRect),           // wSrcWidth
							   RECTHEIGHT(lpDIBRect),          // wSrcHeight
							   lpDIBBits,                      // lpBits
							   (LPBITMAPINFO)lpDIBHdr,         // lpBitsInfo
							   DIB_RGB_COLORS,                 // wUsage
							   SRCCOPY);                       // dwROP
	}
	
    // ????
	::GlobalUnlock((HGLOBAL) hDIB);
	
	// ????????
	if (hOldPal != NULL)
	{
		::SelectPalette(hDC, hOldPal, TRUE);
	}
	
	// ??
	return bSuccess;
}


/*************************************************************************
 *
 * ????:
 *   FindDIBBits()
 *
 * ??:
 *   LPSTR lpbi         - ??DIB?????
 *
 * ???:
 *   LPSTR              - ??DIB????????
 *
 * ??:
 *   ?????DIB??????????,??????????
 *
 ************************************************************************/


ANNRECOGNITION_API LPSTR FindDIBBits(LPSTR lpbi)
{
	return (lpbi + *(LPDWORD)lpbi + ::PaletteSize(lpbi));
}


/*************************************************************************
 *
 * ????:
 *   DIBWidth()
 *
 * ??:
 *   LPSTR lpbi         - ??DIB?????
 *
 * ???:
 *   DWORD              - DIB??????
 *
 * ??:
 *   ?????DIB?????????Windows 3.0 DIB,??BITMAPINFOHEADER
 * ??biWidth?;??????BITMAPCOREHEADER??bcWidth??
 *
 ************************************************************************/


ANNRECOGNITION_API DWORD  DIBWidth(LPSTR lpDIB)
{
	// ??BITMAPINFO?????(Win3.0)
	LPBITMAPINFOHEADER lpbmi;
	
	// ??BITMAPCOREINFO?????
	LPBITMAPCOREHEADER lpbmc;

	// ????
	lpbmi = (LPBITMAPINFOHEADER)lpDIB;
	lpbmc = (LPBITMAPCOREHEADER)lpDIB;

	// ??DIB??????
	if (IS_WIN30_DIB(lpDIB))
	{
		// ??Windows 3.0 DIB,??lpbmi->biWidth
		return lpbmi->biWidth;
	}
	else
	{
		// ???????DIB,??lpbmc->bcWidth
		return (DWORD)lpbmc->bcWidth;
	}
}


/*************************************************************************
 *
 * ????:
 *   DIBHeight()
 *
 * ??:
 *   LPSTR lpDIB        - ??DIB?????
 *
 * ???:
 *   DWORD              - DIB??????
 *
 * ??:
 *   ?????DIB?????????Windows 3.0 DIB,??BITMAPINFOHEADER
 * ??biHeight?;??????BITMAPCOREHEADER??bcHeight??
 *
 ************************************************************************/


ANNRECOGNITION_API DWORD  DIBHeight(LPSTR lpDIB)
{
	// ??BITMAPINFO?????(Win3.0)
	LPBITMAPINFOHEADER lpbmi;
	
	// ??BITMAPCOREINFO?????
	LPBITMAPCOREHEADER lpbmc;

	// ????
	lpbmi = (LPBITMAPINFOHEADER)lpDIB;
	lpbmc = (LPBITMAPCOREHEADER)lpDIB;

	// ??DIB??????
	if (IS_WIN30_DIB(lpDIB))
	{
		// ??Windows 3.0 DIB,??lpbmi->biHeight
		return lpbmi->biHeight;
	}
	else
	{
		// ???????DIB,??lpbmc->bcHeight
		return (DWORD)lpbmc->bcHeight;
	}
}




/*************************************************************************
 *
 * ????:
 *   DIBNumColors()
 *
 * ??:
 *   LPSTR lpbi         - ??DIB?????
 *
 * ???:
 *   WORD               - ???????????
 *
 * ??:
 *   ?????DIB?????????????????,??2,
 * ??16???,??16,??256???,??256;?????
 * ??(24?),?????,??0?
 *
 ************************************************************************/
ANNRECOGNITION_API WORD  DIBNumColors(LPSTR lpbi)
{
	WORD wBitCount;

	// ??Windows?DIB, ??????????????????
	// ??????,???????????
	
	// ?????WIN3.0 DIB
	if (IS_WIN30_DIB(lpbi))
	{
		DWORD dwClrUsed;
		
		// ??dwClrUsed?
		dwClrUsed = ((LPBITMAPINFOHEADER)lpbi)->biClrUsed;
		
		if (dwClrUsed != 0)
		{
			// ??dwClrUsed(????????)??0,??????
			return (WORD)dwClrUsed;
		}
	}

	// ???????
	if (IS_WIN30_DIB(lpbi))
	{
		// ??biBitCount?
		wBitCount = ((LPBITMAPINFOHEADER)lpbi)->biBitCount;
	}
	else
	{
		// ??biBitCount?
		wBitCount = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
	}
	
	// ?????????????
	switch (wBitCount)
	{
		case 1:
			return 2;

		case 4:
			return 16;

		case 8:
			return 256;

		default:
			return 0;
	}
}


/*************************************************************************
 *
 * ????:
 *   DIBBitCount()
 *
 * ??:
 *   LPSTR lpbi         - ??DIB?????
 *
 * ???:
 *   WORD               - ???????????
 *
 * ??:
 *   ?????DIBBitCount?
 *
 ************************************************************************/
ANNRECOGNITION_API WORD  DIBBitCount(LPSTR lpbi)
{
	WORD wBitCount;

	// ???????
	if (IS_WIN30_DIB(lpbi))
	{
		// ??biBitCount?
		wBitCount = ((LPBITMAPINFOHEADER)lpbi)->biBitCount;
	}
	else
	{
		// ??biBitCount?
		wBitCount = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
	}
	
	// ??wBitCount
	return wBitCount;
}

/*************************************************************************
 *
 * ????:
 *   CopyHandle()
 *
 * ??:
 *   HGLOBAL h          - ????????
 *
 * ???:
 *   HGLOBAL            - ?????????
 *
 * ??:
 *   ????????????????????????,?????0?
 *
 ************************************************************************/

ANNRECOGNITION_API HGLOBAL  CopyHandle (HGLOBAL h)
{
	if (h == NULL)
		return NULL;

	// ??????????
	DWORD dwLen = ::GlobalSize((HGLOBAL) h);
	
	// ???????
	HGLOBAL hCopy = ::GlobalAlloc(GHND, dwLen);
	
	// ????????
	if (hCopy != NULL)
	{
		// ??
		void* lpCopy = ::GlobalLock((HGLOBAL) hCopy);
		void* lp     = ::GlobalLock((HGLOBAL) h);
		
		// ??
		memcpy(lpCopy, lp, dwLen);
		
		// ????
		::GlobalUnlock(hCopy);
		::GlobalUnlock(h);
	}

	return hCopy;
}



/*************************************************************************
 *
 * ????:
 *   SaveDIB()
 *
 * ??:
 *   HDIB hDib          - ????DIB
 *   CFile& file        - ????CFile
 *
 * ???:
 *   BOOL               - ????TRUE,????FALSE??CFileException
 *
 * ??:
 *   ???????DIB????????CFile???CFile???????????
 *
 *************************************************************************/


ANNRECOGNITION_API BOOL  SaveDIB(HDIB hDib, LPCSTR fileName)
{
	// Bitmap???
	BITMAPFILEHEADER bmfHdr;
	
	// ??BITMAPINFOHEADER???
	LPBITMAPINFOHEADER lpBI;
	
	// DIB??
	DWORD dwDIBSize;

	if (hDib == NULL)
	{
		// ??DIB??,??FALSE
		return FALSE;
	}

	// ??BITMAPINFO??,???
	lpBI = (LPBITMAPINFOHEADER) ::GlobalLock((HGLOBAL) hDib);
	
	if (lpBI == NULL)
	{
		// ??,??FALSE
		return FALSE;
	}
	
	// ?????WIN3.0 DIB
	if (!IS_WIN30_DIB(lpBI))
	{
		// ????????DIB??
		
		// ????
		::GlobalUnlock((HGLOBAL) hDib);
		
		// ??FALSE
		return FALSE;
	}

	// ?????

	// ????"BM"
	bmfHdr.bfType = DIB_HEADER_MARKER;

	// ??DIB???,?????????GlobalSize()????????????
	// ??DIB?????,??????????????????DIB??????
	
	// ?????+?????
	// (BITMAPINFOHEADER?BITMAPCOREHEADER??????DWORD????????)
	dwDIBSize = *(LPDWORD)lpBI + ::PaletteSize((LPSTR)lpBI);
	
	// ??????
	if ((lpBI->biCompression == BI_RLE8) || (lpBI->biCompression == BI_RLE4))
	{
		// ??RLE??,??????,????biSizeImage???
		dwDIBSize += lpBI->biSizeImage;
	}
	else
	{
		// ?????
		DWORD dwBmBitsSize;

		// ???Width * Height
		dwBmBitsSize = WIDTHBYTES((lpBI->biWidth)*((DWORD)lpBI->biBitCount)) * lpBI->biHeight;
		
		// ???DIB?????
		dwDIBSize += dwBmBitsSize;

		// ??biSizeImage(??BMP????biSizeImage??????)
		lpBI->biSizeImage = dwBmBitsSize;
	}


	// ??????:DIB??+BITMAPFILEHEADER????
	bmfHdr.bfSize = dwDIBSize + sizeof(BITMAPFILEHEADER);
	
	// ?????
	bmfHdr.bfReserved1 = 0;
	bmfHdr.bfReserved2 = 0;

	// ?????bfOffBits,?????Bitmap?????+DIB???+?????
	bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + lpBI->biSize
											  + PaletteSize((LPSTR)lpBI);
	
	
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = 1;

	HANDLE hFile = ::CreateFile(fileName, GENERIC_READ|GENERIC_WRITE, 0, &sa,
		CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL, NULL);
	
	if(hFile==INVALID_HANDLE_VALUE)
		return FALSE;

	BOOL bRet=FALSE;

	// ?????
	try
	{	
		do
		{
			DWORD nWritten;
			if (!::WriteFile((HANDLE)hFile, &bmfHdr, sizeof(BITMAPFILEHEADER), &nWritten, NULL))
				break;
			if (!::WriteFile((HANDLE)hFile, lpBI, dwDIBSize, &nWritten, NULL))
				break;
			
			bRet=TRUE;
		
		} while(false);
	}
	catch (exception e)
	{
	}
	// ????
	::GlobalUnlock((HGLOBAL) hDib);
	
	CloseHandle(hFile);
	// ????
	
	return bRet;
}


/*************************************************************************
 *
 * ????:
 *   ReadDIBFile()
 *
 * ??:
 *   CFile& file        - ????????CFile
 *
 * ???:
 *   HDIB               - ????DIB???,????NULL?
 *
 * ??:
 *   ???????????DIB??????????????BITMAPFILEHEADER
 * ????????????
 *
 *************************************************************************/

ANNRECOGNITION_API HDIB  ReadDIBFile(LPCSTR fileName)
{
	BITMAPFILEHEADER bmfHeader;
	DWORD dwBitsSize;
	HDIB hDIB;
	LPSTR pDIB;

	// ??DIB(??)??(??)
	std::ifstream file;
	file.open(fileName,ios::in | ios::binary);
	
	file.seekg (0, ios::end);
	dwBitsSize = file.tellg();
	file.seekg (0, ios::beg);

	// ????DIB???
	file.read((LPSTR)&bmfHeader, sizeof(bmfHeader));
	if (file.flags()==ios::eofbit || file.flags()==ios::badbit || file.flags()==ios::failbit)
	{
		// ????,??NULL?
		file.close();
		return NULL;
	}
	
	// ?????DIB??,??????????"BM"
	if (bmfHeader.bfType != DIB_HEADER_MARKER)
	{
		// ?DIB??,??NULL?
		return NULL;
	}

	// ?DIB????
	hDIB = (HDIB) ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwBitsSize);
	if (hDIB == 0)
	{
		// ??????,??NULL?
		return NULL;
	}
	
	// ??
	pDIB = (LPSTR) ::GlobalLock((HGLOBAL) hDIB);

	// ???
	DWORD dwBitsBegin = file.tellg();

	file.read(pDIB, dwBitsSize - sizeof(BITMAPFILEHEADER));
	
	DWORD dwBitsEnd = file.tellg();

	if ((dwBitsEnd-dwBitsBegin)!=(dwBitsSize - sizeof(BITMAPFILEHEADER)))
	{
		// ?????
		
		// ????
		::GlobalUnlock((HGLOBAL) hDIB);
		
		// ????
		::GlobalFree((HGLOBAL) hDIB);
		
		file.close();
		// ??NULL?
		return NULL;
	}
	
	file.close();

	// ????
	::GlobalUnlock((HGLOBAL) hDIB);
	
	// ??DIB??
	return hDIB;
}
/*******************************************************************
*????:
* NewDIB()
*
* ??:
* width			- ????DIB??
* height			- ????DIB??
* biBitCount		- ????DIB??????,?????256?DIB,????8
*
*???:
*  HDIB           - ????DIB???,????NULL?
*
*??:
*  ????????????????????DIB,??????
*
***************************************************************/
ANNRECOGNITION_API HDIB  NewDIB(long width, long height,unsigned short biBitCount) 
{
	
	//?????DIB????????
	long dwindth = (width*biBitCount/8+3)/4*4;

	//???DIB????????? 
	 WORD color_num;
   
     //?????biBitCount???????????? 
	switch(biBitCount)
	{   

       //???1 bit?????????????????? 
		case 1:
         color_num=2;
		break;

       //???4 bit??????????????16???
		case 4:
		color_num=16;
		break;

       //???8bit???????,??????????256?(???????????)
		case 8:
		color_num=256;
		break;

       //?????????????,?????
		default:
		color_num=0;
		break;
	}

	//???????????
	//dwindth *height??????????
	//40??????????
	//color_num*4????????????(????????4????)

	 long   dwBitsSize = dwindth *height + 40 + color_num*4;

	//??????????? 
	LPSTR pDIB;

	//??????,??????????
	HDIB hDIB=(HDIB) ::GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, dwBitsSize);

	//???????????????
	if (hDIB == 0)
	{
		return NULL;
	}

   //????????????,?????????pDIB
	pDIB = (LPSTR) ::GlobalLock((HGLOBAL) hDIB);
	
   //??????????????
	LPBITMAPINFO lpmf = (LPBITMAPINFO)pDIB;

   //??????????????

   //?????????????40??
	lpmf->bmiHeader.biSize = 40;

   //?????????
	lpmf->bmiHeader.biWidth = width;

   //?????????
	lpmf->bmiHeader.biHeight = height;

   //???????1
	lpmf->bmiHeader.biPlanes = 1;

	//???????????????bit?
	lpmf->bmiHeader.biBitCount = biBitCount;

    //??????
	lpmf->bmiHeader.biCompression = 0;

    //???????????????????
	lpmf->bmiHeader.biSizeImage = dwindth *height;

	//????????????
	lpmf->bmiHeader.biXPelsPerMeter = 2925;

    //????????????
	lpmf->bmiHeader.biYPelsPerMeter = 2925;

	//???????????? ???0????????2?biBitCount?
	lpmf->bmiHeader.biClrUsed = 0;
 
	//?????????????,???0?????????
	lpmf->bmiHeader.biClrImportant= 0; 	
    
    //?????????????,???????????????????
	if(color_num!=0)
	{
		for(int i=0;i<color_num;i++)
		{
			lpmf->bmiColors[i].rgbRed =(BYTE)i;
			lpmf->bmiColors[i].rgbGreen =(BYTE)i;
			lpmf->bmiColors[i].rgbBlue =(BYTE)i;
		}
	}

	//????
	::GlobalUnlock((HGLOBAL) hDIB);

	//?????????
	 return hDIB;

}


/*************************************************************************
 *
 * ????:
 *   PaletteSize()
 *
 * ??:
 *   LPSTR lpbi         - ??DIB?????
 *
 * ???:
 *   WORD               - DIB???????
 *
 * ??:
 *   ?????DIB??????????Windows 3.0 DIB,??????×
 * RGBQUAD???;??????????×RGBTRIPLE????
 *
 ************************************************************************/
ANNRECOGNITION_API WORD  PaletteSize(LPSTR lpbi)
{
	// ??DIB???????
	if (IS_WIN30_DIB (lpbi))
	{
		//??????×RGBQUAD???
		return (WORD)(::DIBNumColors(lpbi) * sizeof(RGBQUAD));
	}
	else
	{
		//??????×RGBTRIPLE???
		return (WORD)(::DIBNumColors(lpbi) * sizeof(RGBTRIPLE));
	}
}
